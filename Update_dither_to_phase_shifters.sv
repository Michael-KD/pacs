// -------------------------------------------------------------
// 
// File Name: C:\Users\Laser Phased Array\Desktop\SimuLink Simulations\Systemverilog code from HDL coder\v5 - globally 
// generalized state machine\Simulink_SPGD_simulation_HDL_code_generator_v5_5\Update_dither_to_phase_shifters.s
// Created: 2025-03-06 18:12:06
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


import Subsystem_pkg::* ;

// -------------------------------------------------------------
// 
// Module: Update_dither_to_phase_shifters
// Source Path: Simulink_SPGD_simulation_HDL_code_generator_v5_5/Subsystem/SPGD Subsystem/Update dither to phase 
// shifter
// Hierarchy Level: 2
// Model version: 1.49
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Update_dither_to_phase_shifters
          (  input logic clk,
             input logic reset,
             input logic enb,
             input logic [15:0] Orms  /* ufix16_En16 */,
             input logic [15:0] beta1,
             input vector_of_signed_logic_16 Di_k[0:7]  /* sfix16_En16 [8] */,
             input logic [15:0] S  /* ufix16_En6 */,
             input logic [15:0] S_1  /* ufix16_En6 */,
             input logic [15:0] g  /* ufix16_En15 */,
             input vector_of_signed_logic_16 Ai_k[0:7]  /* sfix16_En11 [8] */,
             input logic [15:0] g_leakage  /* ufix16_En15 */,
             input logic [15:0] iteration_counter  /* ufix16_En11 */,
             input logic [2:0] state_tracker,
             input logic [15:0] epoch_counter_in,
             input logic Enable,
             output vector_of_signed_logic_16 Updated_Dither[0:7]  /* sfix16_En11 [8] */,
             output logic [15:0] counter_feedback  /* ufix16_En11 */,
             output logic [15:0] delta_S,
             output logic [15:0] epoch_counter_out);


  logic enb_gated;
  logic update_enable;
  logic update_dither_enable;
  logic update_input_enable;
  logic done_enable;
  logic counter_done_enable;
  logic is_negative;
  logic signed [31:0] Subtract_sub_cast;  /* sfix32_En6 */
  logic signed [31:0] Subtract_sub_cast_1;  /* sfix32_En6 */
  logic signed [31:0] Subtract_sub_temp1;  /* sfix32_En6 */
  logic signed [31:0] Subtract_sub_temp2;
  logic signed [15:0] Subtract_out1;  /* sfix16_En8 */
  logic signed [31:0] Add_add_cast;  /* ufix32_En6 */
  logic signed [31:0] Add_add_cast_1;  /* ufix32_En6 */
  logic signed [31:0] Add_add_temp;  /* ufix32_En6 */
  logic signed [15:0] Add_out1;  /* ufix16_En3 */
  logic signed [15:0] Divide1_out1;  /* sfix16_En5 */
  logic signed [16:0] Product4_cast;  /* sfix17_En15 */
  logic signed [32:0] Product4_mul_temp;  /* sfix33_En20 */
  logic signed [31:0] Product4_cast_1;  /* sfix32_En20 */
  logic signed [15:0] Product4_out1;  /* sfix16_En16 */
  logic [31:0] Product_mul_temp;  /* ufix32_En32 */
  logic [15:0] Product_out1;  /* ufix16_En16 */
  vector_of_signed_logic_32 Product3_mul_temp [0:7];  /* sfix32_En32 [8] */
  vector_of_signed_logic_16 Product3_out1 [0:7];  /* sfix16_En16 [8] */
  vector_of_signed_logic_16 Ai_k_last [0:7];
  vector_of_signed_logic_16 Di_k_last [0:7];
  logic [15:0] Constant1_out1;  /* ufix16_En15 */
  logic [15:0] Constant_out1;  /* ufix16_En14 */
  logic [31:0] Product1_mul_temp;  /* ufix32_En30 */
  logic [15:0] Product1_out1;  /* ufix16_En10 */
  logic [15:0] Divide_out1;  /* ufix16_En5 */
  logic signed [15:0] shifted_sub1;
  logic signed [15:0] shifted_sub2;
  vector_of_signed_logic_17 Product2_cast [0:7];  /* sfix17_En5 [8] */
  vector_of_signed_logic_33 Product2_mul_temp [0:7];  /* sfix33_En21 [8] */
  vector_of_signed_logic_32 Product2_cast_1 [0:7];  /* sfix32_En21 [8] */
  vector_of_signed_logic_16 Product2_out1 [0:7];  /* sfix16_En16 [8] */
  vector_of_signed_logic_17 Product5_cast [0:7];  /* sfix17_En15 [8] */
  vector_of_signed_logic_33 Product5_mul_temp [0:7];  /* sfix33_En26 [8] */
  vector_of_signed_logic_32 Product5_cast_1 [0:7];  /* sfix32_En26 [8] */
  vector_of_signed_logic_16 Product5_out1 [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 momentum1 [0:7];
  vector_of_signed_logic_16 momentum1_out1_last_value [0:7];
  vector_of_signed_logic_16 momentum1_out1_bypass [0:7];
  vector_of_signed_logic_16 momentum1_out1 [0:7];
  vector_of_signed_logic_33 momentum1_tmp1 [0:7];
  vector_of_signed_logic_32 Add1_add_cast [0:7];  /* sfix32_En16 [8] */
  vector_of_signed_logic_32 Add1_add_cast_1 [0:7];  /* sfix32_En16 [8] */
  vector_of_signed_logic_32 Add1_add_temp [0:7];  /* sfix32_En16 [8] */
  vector_of_signed_logic_16 Add1_out1 [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 Add1_out1_bypass [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 Add1_out1_last_value [0:7];  /* sfix16_En13 [8] */
  logic [15:0] vector_counter_out1;  /* ufix16_En11 */
  logic [15:0] vector_counter_out1_bypass;  /* ufix16_En11 */
  logic [15:0] vector_counter_out1_last_value;  /* ufix16_En11 */
  logic signed [23:0] Divide1_div_temp;  /* sfix17_En5 */
  logic signed [16:0] Divide1_cast;  /* sfix17_En3 */
  logic [31:0] Divide_div_temp;  /* ufix16_En5 */
  logic previous_enb_hold;


  assign enb_gated = Enable && enb;
  assign update_input_enable = state_tracker == 3'b110;
  assign update_enable = Enable && counter_done_enable;
  assign update_dither_enable = Enable && done_enable;
  
  logic [15:0] S_last;
  logic [15:0] S_1_last;
  logic [15:0] iteration_counter_last;
  logic [15:0] epoch_counter_last;
  always_ff @(posedge clk or posedge reset)
    begin : input_handling
      if (reset == 1'b1) begin
        S_last <= 16'b0000000000000000;
		S_1_last <= 16'b0000000000000000;
		iteration_counter_last <= 16'b0000000000000000;
		epoch_counter_last <= 16'b0;
      end
      else begin
        if (update_input_enable) begin
          S_last <= S;
		  S_1_last <= S_1;
		  iteration_counter_last <= iteration_counter;
		  epoch_counter_last <= epoch_counter_in;
        end
      end
    end
  
  genvar i_input;
  generate
    for(i_input = 32'sd0; i_input <= 32'sd7; i_input = i_input + 32'sd1) begin:input_handling_dither
      always_ff @(posedge clk or posedge reset)
         begin 
            if (reset == 1'b1) begin
               Ai_k_last[i_input] <= 16'b0000000000000000;
		       Di_k_last[i_input] <= 16'b0000000000000000;
            end
            else begin
               if (update_input_enable) begin
                  Ai_k_last[i_input] <= Ai_k[i_input];
		          Di_k_last[i_input] <= Di_k[i_input];
               end
            end
       end
    end
  endgenerate
  
  assign Subtract_sub_cast = {16'b0, S_1_last};/*sfix32_frac11*/
  assign Subtract_sub_cast_1 = {16'b0, S_last};
  assign Subtract_sub_temp1 = Subtract_sub_cast - Subtract_sub_cast_1;
  assign Subtract_sub_temp2 = Subtract_sub_cast_1 - Subtract_sub_cast;
  assign shifted_sub1 = Subtract_sub_temp1[15:0];/*sfix16_frac11*/
  assign shifted_sub2 =  ~Subtract_sub_temp2[15:0] + 16'b0000000000000001;

  assign is_negative = Subtract_sub_cast < Subtract_sub_cast_1;
  //assign Subtract_out1 = (is_negative == 1'b0 ? shifted_sub1  : shifted_sub2
             //);
  logic signed [15:0] S_plus;
  logic signed [15:0] S_minus;
  assign S_plus = S_1_last;
  assign S_minus = S_last;
  assign Subtract_out1 = S_plus - S_minus;
  

  assign Add_add_cast = {{17{S_1_last[15]}}, S_1_last[14:0]};
  assign Add_add_cast_1 = {{17{S_last[15]}}, S_last[14:0]};
  assign Add_add_temp = Add_add_cast + Add_add_cast_1;/*sfix32_frac11*/
  assign Add_out1 = Add_add_temp[16:1];/*sfix16_frac10*/
  assign delta_S = Subtract_out1;
 

  logic signed [16:0] signed_add_out1;
  logic signed [31:0] extended_subtract_out1;
  assign signed_add_out1 = {1'b0, Add_out1[15:0]};/*sfix17_frac10*/
  assign extended_subtract_out1 = {Subtract_out1, 16'b0};/*sfix32_frac27*/
  assign Divide1_div_temp = extended_subtract_out1 / Add_out1;/*sfix32_frac17*/
  assign Divide1_out1 = Divide1_div_temp[17:2];/*sfix16_frac15*/
  



  logic signed [15:0] log_amp_sub;
  assign log_amp_sub = ~Subtract_sub_temp1[15:0]+ 16'b0000000000000001; /*sfix16_frac12*/
  assign Product4_cast = {1'b0, g};/*gain, sfix17frac15*/
  assign Product4_mul_temp = Product4_cast * Divide1_out1;/*sfix33frac30*//*sfix33frac27 - logamp*/
  assign Product4_cast_1 = Product4_mul_temp[31:0];/*sfix32frac30*//*sfix33frac27*/
  always_comb begin
  if (Product4_mul_temp[32] == 1'b1) begin
      Product4_out1 = {1'b1, Product4_cast_1[29:15]};/*sfix16_15frac*/
  end
  else begin
      Product4_out1 = {1'b0, Product4_cast_1[29:15]};/*sfix16_15frac*/
  end
  end
  /*assign Product4_out1 = Product4_cast_1[19:4];*/



  assign Product_mul_temp = Orms * Orms;
  assign Product_out1 = Product_mul_temp[31:16];/*ufix16frac16*/




  genvar t_04;
  generate
    for(t_04 = 32'sd0; t_04 <= 32'sd7; t_04 = t_04 + 32'sd1) begin:Product3_out1_gen
      assign Product3_mul_temp[t_04] = Product4_out1 * Di_k_last[t_04];/*sfix32_frac30*/
		always_comb begin
		if (Product3_mul_temp[t_04][31] == 1'b1) begin
          Product3_out1[t_04] = {1'b1,  Product3_mul_temp[t_04][29:15]};/*sfix16_15frac*/
      end
      else begin
          Product3_out1[t_04] = {1'b0,  Product3_mul_temp[t_04][29:15]};
      end
		end
      /*assign Product3_out1[t_04] = Product3_mul_temp[t_04][31:16];*/
    end
  endgenerate




  assign Constant1_out1 = 16'b1000000000000000;/*ufix16_frac15*/



  assign Constant_out1 = 16'b1000000000000000;/*ufix16frac14*/



  assign Product1_mul_temp = Product_out1 * Constant_out1;/*ufix32frac30*/
  assign Product1_out1 = Product1_mul_temp[31:16];/*ufix16_frac14*/

  logic [31:0] Constant1_tmp;
  assign Constant1_tmp = {Constant1_out1, 16'b0};/*ufix32_frac31*/
  assign Divide_div_temp = Constant1_tmp / Product1_out1;/*ufix32_frac17*/
  assign Divide_out1 = Divide_div_temp[27:12];/*ufix16_frac5*/
 


  /*final product term for gradient part*/
  genvar t_011;
  generate
    for(t_011 = 32'sd0; t_011 <= 32'sd7; t_011 = t_011 + 32'sd1) begin:Product2_out1_gen
      assign Product2_cast[t_011] = {1'b0, Divide_out1};/*sfix17_frac5*/
      assign Product2_mul_temp[t_011] = Product3_out1[t_011] * Product2_cast[t_011];/*sfix33_frac20*/
      assign Product2_cast_1[t_011] = Product2_mul_temp[t_011][31:0];/*sfix32_frac20*/
		always_comb begin
		if (Product2_mul_temp[t_011][32] == 1'b1) begin
          Product2_out1[t_011] = {1'b1,  Product2_cast_1[t_011][23:9]};/*sfix16_11frac*/
      end
      else begin
          Product2_out1[t_011] = {1'b0,  Product2_cast_1[t_011][23:9]};
      end
		end
      /*assign Product2_out1[t_011] = Product2_cast_1[t_011][20:5];*/
    end
  endgenerate




  /*final product term for g_leakage part1*/
  genvar t_021;
  generate
    for(t_021 = 32'sd0; t_021 <= 32'sd7; t_021 = t_021 + 32'sd1) begin:Product5_out1_gen
      assign Product5_cast[t_021] = {1'b0, g_leakage};/*sfix17_frac15*/
      assign Product5_mul_temp[t_021] = Ai_k_last[t_021] * Product5_cast[t_021];/*sfix33_frac26*/
      assign Product5_cast_1[t_021] = Product5_mul_temp[t_021][31:0];/*sfix32_frac26*/
		always_comb begin
		if (Product5_mul_temp[t_021][32] == 1'b1) begin
          Product5_out1[t_021] = {1'b1,  Product5_cast_1[t_021][29:15]};/*sfix16_11frac*/
      end
      else begin
          Product5_out1[t_021] = {1'b0,  Product5_cast_1[t_021][29:15]};
      end
		end
      /*assign Product5_out1[t_021] = Product5_cast_1[t_021][28:13];*/
    end
  endgenerate




                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
  genvar t_031;
  generate
    for(t_031 = 32'sd0; t_031 <= 32'sd7; t_031 = t_031 + 32'sd1) begin:Add1_out1_gen
      /*assign Add1_add_cast[t_031] = {{16{Product2_out1[t_031][15]}}, Product2_out1[t_031]};
      assign Add1_add_cast_1[t_031] = {{13{Product5_out1[t_031][15]}}, {Product5_out1[t_031], 3'b000}};
      assign Add1_add_temp[t_031] = Add1_add_cast[t_031] + Add1_add_cast_1[t_031];
      assign Add1_out1[t_031] = Add1_add_temp[t_031][18:3];*/
        always_comb begin
        if (iteration_counter <= 16'b0010000000000000) begin
		    Add1_out1[t_031] = Product2_out1[t_031] + Product5_out1[t_031];/*sfix16_11frac*/
		end
		else begin
		    Add1_out1[t_031] = Product2_out1[t_031] + Product5_out1[t_031];/*sfix16_11frac*/
		end
		end
		assign momentum1_out1[t_031] = momentum1[t_031] + Product5_out1[t_031];/*sfix16_11frac*/
    end
  endgenerate
  
  
  logic [32:0] i;
  always_ff @(posedge clk or posedge reset)
  begin: done_enable_control
      if (reset == 1'b1) begin
          done_enable <= 1'b1;
      end
		else begin
		    if (Enable == 1'b1) begin
			     for (i = 32'sd0; i <= 32'sd7; i = i + 32'sd1) begin
			         if (Add1_out1_last_value[i] != Add1_out1[i]) begin
				          done_enable <= 0;
						end
			     end 
			 end
			 else begin
			     done_enable <= 1'b1;
			 end
		    
		end
  end
  
  always_ff @(posedge clk or posedge reset)
  begin: counter_done_enable_control
      if (reset == 1'b1) begin
          counter_done_enable <= 1'b1;
      end
		else begin
		    if (Enable == 1'b1) begin
			     if (vector_counter_out1_last_value != vector_counter_out1) begin
				      counter_done_enable <= 0;
			     end
			 end
			 else begin
			     counter_done_enable <= 1;
			 end
		    
		end
  end
  




  always_ff @(posedge clk or posedge reset)
    begin : Updated_Dither_bypass_process
      if (reset == 1'b1) begin
        Add1_out1_last_value <= '{8{16'sb0000000000000000}};
        momentum1_out1_last_value <= '{8{16'sb0000000000000000}};
      end
      else begin
        if (enb_gated) begin
          Add1_out1_last_value <= Add1_out1_bypass;
          momentum1_out1_last_value <= momentum1_out1_bypass;
        end
      end
    end
  
  logic signed [16:0] beta1_casted;
  assign beta1_casted = {1'b0, beta1};
  genvar t_035;
  generate
    for(t_035 = 32'sd0; t_035 <= 32'sd7; t_035 = t_035 + 32'sd1) begin:momentum1_tmp_assignements
		assign momentum1_tmp1[t_035] = momentum1[t_035] * beta1 + (17'sb01000000000000000 - beta1_casted) * Product2_out1[t_035];/*sfix33_En26*/
    end
  endgenerate
  
  logic update_dither_enable_single_pulse;
  logic update_dither_enable_delay;
  always_ff @(posedge clk or posedge reset)
    begin 
      if (reset) begin
        update_dither_enable_delay <= 1'b0;
      end
      else begin
        update_dither_enable_delay <= update_dither_enable;
      end
    end
  assign update_dither_enable_single_pulse = update_dither_enable && (~update_dither_enable_delay);
  always_ff @(posedge clk or posedge reset)
    begin : Update_momentum1
      if (reset == 1'b1) begin
        momentum1 <= '{8{16'sb0}};
      end
      else begin
         for (i = 32'sd0; i <= 32'sd7; i = i + 32'sd1) begin
			    if (update_dither_enable_single_pulse) begin
			        momentum1[i] <= momentum1_tmp1[i][30:15];
			    end
			    else begin
			        momentum1[i] <= momentum1[i];
			    end 
	     end 
	     
      end
    end


  assign Add1_out1_bypass = (enb_gated == 1'b0 ? Add1_out1_last_value :
              Add1_out1);
  assign momentum1_out1_bypass = (update_dither_enable == 1'b0 ? momentum1_out1_last_value :
              momentum1_out1);



  assign Updated_Dither = Add1_out1_bypass;

  vector_counter u_vector_counter (.u(iteration_counter_last),  /* ufix16_En11 */
                                   .y(vector_counter_out1)  /* ufix16_En11 */
                             );
  logic [15:0] epoch_counter_out_last_value;
  logic [15:0] epoch_counter_out1;
  logic [15:0] epoch_counter_out_bypass;
  always_comb
    begin
      if (vector_counter_out1 == 16'b0000100000000000) begin
        epoch_counter_out1 = epoch_counter_last + 16'b1;
        end
      else begin
        epoch_counter_out1 = epoch_counter_last;
        end
    end
  always_ff @(posedge clk or posedge reset)
    begin : counter_feedback_bypass_process
      if (reset == 1'b1) begin
        vector_counter_out1_last_value <= 16'b0000000000000000;
        epoch_counter_out_last_value <= 16'b0;
      end
      else begin
        if (enb_gated) begin
          vector_counter_out1_last_value <= vector_counter_out1_bypass;
          epoch_counter_out_last_value <= epoch_counter_out_bypass;
        end
      end
    end


  logic [2:0] index_rnd;
  logic [15:0] index_rnd_expanded;
  always_ff @ (posedge clk or posedge reset) begin
     if (reset) begin
        index_rnd <= 3'b101;
     end
     else begin
        index_rnd <= {index_rnd[1]^index_rnd[0], index_rnd[2], index_rnd[1]};
     end
  end
  assign index_rnd_expanded = {2'b0, index_rnd, 11'b0};
  
  assign vector_counter_out1_bypass = (enb_gated == 1'b0 ? vector_counter_out1_last_value :
              vector_counter_out1);
  assign epoch_counter_out_bypass = (enb_gated == 1'b0 ? epoch_counter_out_last_value :
              epoch_counter_out1);



  assign counter_feedback = vector_counter_out1_bypass;
  
  assign epoch_counter_out = epoch_counter_out_bypass;

endmodule  // Update_dither_to_phase_shifters

