// -------------------------------------------------------------
// 
// File Name: C:\Users\Laser Phased Array\Desktop\SimuLink Simulations\Systemverilog code from HDL coder\v5 - globally 
// generalized state machine\Simulink_SPGD_simulation_HDL_code_generator_v5_5\SPGD_Subsystem.s
// Created: 2025-03-06 18:12:06
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


import Subsystem_pkg::* ;

// -------------------------------------------------------------
// 
// Module: SPGD_Subsystem
// Source Path: Simulink_SPGD_simulation_HDL_code_generator_v5_5/Subsystem/SPGD Subsystem
// Hierarchy Level: 1
// Model version: 1.49
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SPGD_Subsystem
          (  input logic clk,
             input logic [15:0] DAC_in,
             input logic reset,
             input logic enb,
             input logic [15:0] PM_index,
             input logic [15:0] g  /* ufix16_En12 */,
             input logic [15:0] g_leakage  /* ufix16_En15 */,
             input logic [15:0] orms  /* ufix16_En16 */,
             input logic [15:0] beta1,
             input vector_of_signed_logic_16 dither_in[0:7] [0:7]  /* sfix16_En16 [8x8] */,
             input logic [15:0] pseudo_clk  /* ufix16_En5 */,
             input logic [15:0] measured_signal,
             input vector_of_unsigned_logic_16 wait_times[0:7]  /* ufix16_En12 [8] */,
             input vector_of_unsigned_logic_16 hold_times[0:7]  /* ufix16_En13 [8] */,
             input logic [15:0] V2pi  /* ufix16_En12 */,
             input logic Enable,
             output logic [15:0] out_monitor  /* ufix16_En11 */,
             output logic DAC_enable_out,
             output logic ADC1_enable_out,
             output logic [2:0] state_out  /* ufix16_En11 */,
			 output logic [15:0] counter_feedback,
		     output logic [15:0] updated_dither_monitor1,
			 output logic [15:0] updated_dither_monitor2,
			 input  logic         dco,             
             input  logic [15:0]  data,   
             input logic [3:0] epoch_bit_select,        
             output vector_of_signed_logic_12 DAC_out [0:7],
             output [7:0] wr,
             output logic cnv_adc,
             output logic cnv_adc2,
             output logic [15:0] data_captured,
             output logic [15:0] PM0,
             output logic [15:0] PMP0,
             output logic [15:0] PMM0,
             output logic [15:0] dither0,
             output logic [15:0] delta_S);
             


  logic enb_gated;
  logic cnv;
  logic [15:0] Constant5_out1;  /* ufix16_En15 */
  logic [28:0] Relational_Operator_1_cast;  /* ufix29_En15 */
  logic [28:0] Relational_Operator_1_cast_1;  /* ufix29_En15 */
  logic Relational_Operator_relop1;
  logic switch_compare_1;
  logic [15:0] Constant4_out1;  /* ufix16_En15 */
  logic [15:0] Constant4_out1_dtc;  /* ufix16_En12 */
  logic switch_compare_1_1;
  logic signed [15:0] Constant2_out1;  /* sfix16_En4 */
  logic [15:0] Constant2_out1_dtc;  /* ufix16_En11 */
  logic switch_compare_1_2;
  logic [15:0] Constant4_out1_dtc_1;  /* ufix16_En11 */
  logic [2:0] state_machine_out9;  /* ufix16_En11 */
  logic [2:0] Unit_Delay5_out1;  /* ufix16_En11 */
  logic [2:0] Switch5_out1;  /* ufix16_En11 */
  logic [2:0] state_machine_out8;  /* ufix16_En11 */
  logic [2:0] Unit_Delay4_out1;  /* ufix16_En11 */
  logic [2:0] Switch3_out1;  /* ufix16_En11 */
  logic [15:0] state_machine_out1;  /* ufix16_En12 */
  logic [15:0] Unit_Delay1_out1;  /* ufix16_En12 */
  logic [15:0] Switch1_out1;  /* ufix16_En12 */
  logic state_machine_out2;
  logic state_machine_out3;
  logic state_machine_out4;
  logic state_machine_out5;
  logic state_machine_out6;
  logic state_machine_out7;
  logic [15:0] state_machine_out10;  /* ufix16_En14 */
  logic switch_compare_1_3;
  logic switch_compare_1_4;
  logic [15:0] Constant1_out1;  /* ufix16_En15 */
  logic [15:0] Constant1_out1_dtc;  /* ufix16_En11 */
  vector_of_signed_logic_16 select_vector_out1 [0:7];  /* sfix16_En16 [8] */
  vector_of_signed_logic_16 Unit_Delay3_out1 [0:7];  /* sfix16_En11 [8] */
  vector_of_signed_logic_16 perturb_dither_plus_out1 [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 Update_dither_to_phase_shifters_out1 [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 vector_handle_out1 [0:7];  /* sfix16_En11 [8] */
  logic [15:0] ADC_J_plus_out1;  /* ufix16_En6 */
  logic [15:0] Unit_Delay7_out1;  /* ufix16_En6 */
  logic [15:0] wave_propagation_out1;  /* ufix16_En6 */
  logic [15:0] ADC_J_minus_out1;  /* ufix16_En6 */
  logic [15:0] Unit_Delay2_out1;  /* ufix16_En11 */
  logic [15:0] Update_dither_to_phase_shifters_out2;  /* ufix16_En11 */
  logic [15:0] Switch2_out1;  /* ufix16_En11 */
  logic [15:0] zero_handle_out1;  /* ufix16_En11 */
  vector_of_signed_logic_16 perturb_dither_minus_out1 [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 Switch4_out1 [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 Unit_Delay6_out1 [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 DAC1_out1 [0:7];  /* sfix16_En13 [8] */
  vector_of_signed_logic_16 add_copy [0:7];
  vector_of_signed_logic_16 sub_copy [0:7];
  logic [15:0] ADC_J_plus_out1_bypass;  /* ufix16_En6 */
  logic [15:0] ADC_J_plus_out1_last_value;  /* ufix16_En6 */
  logic state_machine_out2_bypass;
  logic state_machine_out2_last_value;
  logic state_machine_out3_bypass;
  logic state_machine_out3_last_value;
  logic [15:0] Unit_Delay4_out1_bypass;  /* ufix16_En11 */
  logic [15:0] Unit_Delay4_out1_last_value;  /* ufix16_En11 */
  logic cnv1;
  logic cnv2;
  logic clk_adc_out1;
  logic clk_adc_out2;


  assign enb_gated = Enable && enb;

  assign Constant5_out1 = 16'b0000000000000000;



  assign Relational_Operator_1_cast = {pseudo_clk, 13'b0000000000000};
  assign Relational_Operator_1_cast_1 = {13'b0, Constant5_out1};
  assign Relational_Operator_relop1 = Relational_Operator_1_cast < Relational_Operator_1_cast_1;



  assign switch_compare_1 = Relational_Operator_relop1 > 1'b0;



  assign Constant4_out1 = 16'b1000000000000000;



  assign Constant4_out1_dtc = {3'b0, Constant4_out1[15:3]};



  assign switch_compare_1_1 = Relational_Operator_relop1 > 1'b0;



  assign Constant2_out1 = 16'sb0000000000000000;



  assign Constant2_out1_dtc = {Constant2_out1[8:0], 7'b0000000};



  assign switch_compare_1_2 = Relational_Operator_relop1 > 1'b0;



  assign Constant4_out1_dtc_1 = {4'b0, Constant4_out1[15:4]};



  always_ff @(posedge clk or posedge reset)
    begin : Unit_Delay5_process
      if (reset == 1'b1) begin
        Unit_Delay5_out1 <= 3'b000;
      end
      else begin
        if (enb_gated) begin
          Unit_Delay5_out1 <= state_machine_out9;
        end
      end
    end



  assign Switch5_out1 = (switch_compare_1_2 == 1'b0 ? Unit_Delay5_out1 :
              3'b000);



  always_ff @(posedge clk or posedge reset)
    begin : Unit_Delay4_process
      if (reset == 1'b1) begin
        Unit_Delay4_out1 <= 3'b000;
      end
      else begin
        if (enb_gated) begin
          Unit_Delay4_out1 <= state_machine_out8;
        end
      end
    end



  assign Switch3_out1 = (switch_compare_1_1 == 1'b0 ? Unit_Delay4_out1 :
              3'b000);



  always_ff @(posedge clk or posedge reset)
    begin : Unit_Delay1_process
      if (reset == 1'b1) begin
        Unit_Delay1_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb_gated) begin
          Unit_Delay1_out1 <= state_machine_out1;
        end
      end
    end



  assign Switch1_out1 = (switch_compare_1 == 1'b0 ? Unit_Delay1_out1 :
              Constant4_out1_dtc);



  state_machine u_state_machine (.clk(clk),
                                 .counter_in(Switch1_out1),  /* ufix16_En12 */
                                 .cur_state(Switch3_out1),  /* ufix16_En11 */
                                 .projected_state_in(Switch5_out1),  /* ufix16_En11 */
                                 .wait_time_batch(wait_times),  /* ufix16_En12 [8] */
                                 .hold_time_batch(hold_times),  /* ufix16_En14 [8] */
                                 .counter_out(state_machine_out1),  /* ufix16_En12 */
                                 .DAC_enable_out(state_machine_out2),
                                 .J_plus_ADC_enable_out(state_machine_out3),
                                 .J_minus_ADC_enable_out(state_machine_out4),
                                 .plus_perturb_enable_out(state_machine_out5),
                                 .minus_perturb_enable_out(state_machine_out6),
                                 .SPGD_update_enable_out(state_machine_out7),
                                 .next_state(state_machine_out8),  /* ufix16_En11 */
                                 .projected_state(state_machine_out9),  /* ufix16_En11 */
                                 .plus_minus_select(state_machine_out10)  /* ufix16_En14 */
                                 );
  logic ADC1_enb_reg;
  logic DAC_enb_reg;
  logic ADC2_enb_reg;
  logic ditherup_enb_reg;
  logic ditherdown_enb_reg;
  logic updatesys_enb_reg;
  
  always_ff @ (posedge clk or posedge reset) begin
      if (reset) begin
          ADC1_enb_reg <= 1'b0;
          DAC_enb_reg <= 1'b0;
          ADC2_enb_reg <= 1'b0;
          ditherup_enb_reg <= 1'b0;
          ditherdown_enb_reg <= 1'b0;
          updatesys_enb_reg <= 1'b0;
      end
      else begin
          ADC1_enb_reg <= state_machine_out3;
          DAC_enb_reg <= state_machine_out2;
          ADC2_enb_reg <= state_machine_out4;
          ditherup_enb_reg <= state_machine_out5;
          ditherdown_enb_reg <= state_machine_out6;
          updatesys_enb_reg <= state_machine_out7;
      end
  end

  assign switch_compare_1_3 = state_machine_out10 > 16'b0000000000000000;



  assign switch_compare_1_4 = Relational_Operator_relop1 > 1'b0;



  assign Constant1_out1 = 16'b1000000000000000;



  assign Constant1_out1_dtc = {4'b0, Constant1_out1[15:4]};



  perturb_dither_plus u_perturb_dither_plus (.clk(clk),
                                             .reset(reset),
                                             .enb(enb_gated),
                                             .V2pi(V2pi),
                                             .dither_in(select_vector_out1),  /* sfix16_En16 [8] */
                                             .phase_shiter_vector(Unit_Delay3_out1),  /* sfix16_En11 [8] */
                                             .Enable(ditherup_enb_reg),
                                             .dither_out(perturb_dither_plus_out1)  /* sfix16_En13 [8] */,
                                             .add_out_copy(add_copy)
                                             );

  vector_handle u_vector_handle (.reset_1(Relational_Operator_relop1),
                                 .clk(clk),
                                 .V2pi(V2pi),  /* ufix16_En12 */
                                 .v_in(Update_dither_to_phase_shifters_out1),  /* sfix16_En13 [8] */
                                 .v_out(vector_handle_out1)  /* sfix16_En11 [8] */
                                 );

  always_ff @(posedge clk or posedge reset)
    begin : Unit_Delay3_process
      if (reset == 1'b1) begin
        Unit_Delay3_out1 <= '{8{16'sb0010100011000000}};
      end
      else begin
        if (enb_gated) begin
          Unit_Delay3_out1 <= vector_handle_out1;
        end
      end
    end



  always_ff @(posedge clk or posedge reset)
    begin : Unit_Delay7_process
      if (reset == 1'b1) begin
        Unit_Delay7_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb_gated) begin
          Unit_Delay7_out1 <= ADC_J_plus_out1;
        end
      end
    end



  ADC_J_minus u_ADC_J_minus (.clk(clk),
                             .reset(reset),
                             .enb(enb_gated),
                             .Enable(ADC2_enb_reg),
                             .DO_rsvd(ADC_J_minus_out1),  /* ufix16_En6 */
                             .dco(dco),             
                             .data(data)          
                             );
                             
  ADC_J_plus u_ADC_J_plus (.clk(clk),
                           .reset(reset),
                           .enb(enb_gated),
                           .Enable(ADC1_enb_reg),
                           .DO_rsvd(ADC_J_plus_out1),  /* ufix16_En6 */
                           .dco(dco),             
                           .data(data)
                           );
                           
  //logic [15:0] S_hardwired;
  //logic [15:0] S_hardwired_1;
  //assign S_hardwired = 16'd2;
  //assign S_hardwired_1 = 16'd1;
  logic [15:0] epoch_counter;
  logic [15:0] epoch_counter_in;
  logic [15:0] epoch_counter_out;
  always_ff @(posedge clk or posedge reset) begin
      if (reset) begin
          epoch_counter <= 16'b0;
          epoch_counter_in <= 16'b0;
      end
      else begin
          epoch_counter <= epoch_counter_out;
          epoch_counter_in <= epoch_counter;
      end
  end
  Update_dither_to_phase_shifters u_Update_dither_to_phase_shifters (.clk(clk),
                                                                     .reset(reset),
                                                                     .enb(enb_gated),
                                                                     .Orms(orms),  /* ufix16_En16 */
                                                                     .beta1(beta1),
                                                                     .Di_k(select_vector_out1),  /* sfix16_En16 [8] */
                                                                     .S(ADC_J_minus_out1),  /* ufix16_En11 ADC_J_minus_out1*/
                                                                     .S_1(Unit_Delay7_out1),  /* ufix16_En11 Unit_Delay7_out1*/
                                                                     .g(g),  /* ufix16_En12 */
                                                                     .Ai_k(Unit_Delay3_out1),  /* sfix16_En11 [8] */
                                                                     .g_leakage(g_leakage),  /* ufix16_En15 */
                                                                     .iteration_counter(Unit_Delay2_out1),  /* ufix16_En11 */
                                                                     .Enable(updatesys_enb_reg),
																	 .state_tracker(Unit_Delay4_out1),
                                                                     .Updated_Dither(Update_dither_to_phase_shifters_out1),  /* sfix16_En11 [8] */
                                                                     .counter_feedback(Update_dither_to_phase_shifters_out2)  /* ufix16_En11 */,
                                                                     .delta_S(delta_S),
                                                                     .epoch_counter_in(epoch_counter_in),
                                                                     .epoch_counter_out(epoch_counter_out)
                                                                     );
  assign Switch2_out1 = (switch_compare_1_4 == 1'b0 ? Update_dither_to_phase_shifters_out2 :
              Constant1_out1_dtc);



  always_ff @(posedge clk or posedge reset)
    begin : Unit_Delay2_process
      if (reset == 1'b1) begin
        Unit_Delay2_out1 <= 16'b0000000000000000;
      end
      else begin
        if (ditherup_enb_reg) begin
          Unit_Delay2_out1 <= Switch2_out1;
        end
      end
    end



  zero_handle u_zero_handle (.u(Unit_Delay2_out1),  /* ufix16_En11 */
                             .y(zero_handle_out1)  /* ufix16_En11 */
                             );

  select_vector u_select_vector (.clk(clk),
                                 .reset(reset),
                                 .epoch_bit_select(epoch_bit_select),
                                 .epoch(epoch_counter),
                                 .matrix_in(dither_in),  /* sfix16_En16 [8x8] */
                                 .index(zero_handle_out1),  /* ufix16_En11 */
                                 .vector_out(select_vector_out1)  /* sfix16_En16 [8] */
                                 );

  perturb_dither_minus u_perturb_dither_minus (.clk(clk),
                                               .reset(reset),
                                               .enb(enb_gated),
                                               .V2pi(V2pi),
                                               .dither_in(select_vector_out1),  /* sfix16_En16 [8] */
                                               .phase_shiter_vector(Unit_Delay3_out1),  /* sfix16_En11 [8] */
                                               .Enable(ditherdown_enb_reg),
                                               .dither_out(perturb_dither_minus_out1)  /* sfix16_En13 [8] */,
                                               .subtract_out_copy(sub_copy)
                                               );

  assign Switch4_out1 = (switch_compare_1_3 == 1'b0 ? perturb_dither_minus_out1 :
              perturb_dither_plus_out1);


  always_ff @(posedge clk or posedge reset)
    begin : Unit_Delay6_process
      if (reset == 1'b1) begin
        Unit_Delay6_out1 <= '{8{16'sb0000000000000000}};
      end
      else begin
        if (enb_gated) begin
          Unit_Delay6_out1 <= Switch4_out1;
        end
      end
    end


 vector_of_signed_logic_16 DAC_tmp_hardwire[0:7] ;
 /*
 always_ff @ (posedge clk or posedge reset) begin
     if (reset) begin
         DAC_tmp_hardwire <= '{8{16'sb1111111111111111}};
     end
     else begin
         if ((ditherup_enb_reg == 1'b1 && ditherdown_enb_reg == 1'b0)) begin
             DAC_tmp_hardwire <= '{8{16'sb1111111111111111}};
         end
         else if ((ditherup_enb_reg == 1'b0 && ditherdown_enb_reg == 1'b1)) begin
             DAC_tmp_hardwire <= '{8{16'sb0}};
         end
         else begin
             DAC_tmp_hardwire <= DAC_tmp_hardwire;
         end
         
     end
 end
 */
  // assign DAC_tmp_hardwire = '{8{16'sb0010100011000000}};
 
  genvar t_04;
  generate
    for(t_04 = 32'sd0; t_04 <= 32'sd7; t_04 = t_04 + 32'sd1) begin
      assign DAC_tmp_hardwire[t_04] = DAC_in; 
    end
  endgenerate
 
 
  DAC1 u_DAC1 (.clk(clk),
               .reset(reset),
               .enb(enb_gated),
               .DI(Unit_Delay6_out1),  /* sfix16_En13 [8] Unit_Delay6_out1 */
               .Enable(DAC_enb_reg),
               .DAC_out(DAC_out),  /* sfix16_En13 [8] */
               .wr(wr)
               );

  always_ff @(posedge clk or posedge reset)
    begin : out_monitor_bypass_process
      if (reset == 1'b1) begin
        ADC_J_plus_out1_last_value <= 16'b0000000000000000;
      end
      else begin
        if (enb_gated) begin
          ADC_J_plus_out1_last_value <= ADC_J_plus_out1_bypass;
        end
      end
    end



  assign ADC_J_plus_out1_bypass = (Enable == 1'b0 ? ADC_J_plus_out1_last_value :
              ADC_J_plus_out1);



  assign out_monitor = Unit_Delay7_out1; //Unit_Delay7_out1

  always_ff @(posedge clk or posedge reset)
    begin : DAC_enable_out_bypass_process
      if (reset == 1'b1) begin
        state_machine_out2_last_value <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          state_machine_out2_last_value <= state_machine_out2_bypass;
        end
      end
    end



  assign state_machine_out2_bypass = (Enable == 1'b0 ? state_machine_out2_last_value :
              DAC_enb_reg);



  assign DAC_enable_out = state_machine_out2_bypass;

  always_ff @(posedge clk or posedge reset)
    begin : ADC1_enable_out_bypass_process
      if (reset == 1'b1) begin
        state_machine_out3_last_value <= 1'b0;
      end
      else begin
        if (enb_gated) begin
          state_machine_out3_last_value <= state_machine_out3_bypass;
        end
      end
    end



  assign state_machine_out3_bypass = (Enable == 1'b0 ? state_machine_out3_last_value :
              ADC1_enb_reg);



  assign ADC1_enable_out = state_machine_out3_bypass;

  always_ff @(posedge clk or posedge reset)
    begin : state_out_bypass_process
      if (reset == 1'b1) begin
        Unit_Delay4_out1_last_value <= 16'b0000000000000000;
      end
      else begin
        if (enb_gated) begin
          Unit_Delay4_out1_last_value <= Unit_Delay4_out1_bypass;
        end
      end
    end



  assign Unit_Delay4_out1_bypass = (Enable == 1'b0 ? Unit_Delay4_out1_last_value :
              Unit_Delay4_out1);
  
  assign state_out = Unit_Delay4_out1_bypass;
  
  assign counter_feedback = Unit_Delay2_out1;
  
  assign updated_dither_monitor1 = Unit_Delay3_out1[32'd0];
  
  assign updated_dither_monitor2 = Unit_Delay3_out1[32'd1];
  
  assign cnv_adc = ADC1_enb_reg || ADC2_enb_reg;
  
  assign cnv_adc2 = ADC2_enb_reg;
  
  assign cnv = cnv1 || cnv2;
  
  assign clk_adc_out = clk_adc_out1 || clk_adc_out2;
  
  logic J_plus_negedge; 
  logic J_minus_negedge;
  logic J_plus_capture_En;
  logic J_minus_capture_En;
  assign J_plus_capture_En = ~ADC1_enb_reg && J_plus_negedge;
  assign J_minus_capture_En = ~ADC2_enb_reg && J_minus_negedge;
  always_ff @(posedge clk or posedge reset)
    begin
      if (reset == 1'b1) begin
        data_captured <= 16'b0000000000000000;
        J_plus_negedge <= 1'b0;
        J_minus_negedge <= 1'b0;
      end
      else begin
      J_plus_negedge <= ADC1_enb_reg;
      J_minus_negedge <= ADC2_enb_reg;
        if (J_plus_capture_En) begin
          data_captured <= ADC_J_plus_out1;
        end
        else if (J_minus_capture_En) begin
          data_captured <= ADC_J_minus_out1;
        end
      end
    end
     
  //assign data_captured = ADC_J_minus_out1;
  
  assign PM0 = Unit_Delay3_out1[PM_index];
  
  assign PMP0 = {4'b0000, DAC_out[PM_index]};
  
  assign PMM0 = Unit_Delay6_out1[PM_index];
  
  assign dither0 = select_vector_out1[PM_index];
                                                                     
endmodule  // SPGD_Subsystem

