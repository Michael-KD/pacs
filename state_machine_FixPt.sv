// -------------------------------------------------------------
// 
// File Name: C:\Users\Laser Phased Array\Desktop\SimuLink Simulations\Systemverilog code from HDL coder\v5 - globally 
// generalized state machine\Simulink_SPGD_simulation_HDL_code_generator_v5_5\state_machine_FixPt.s
// Created: 2025-03-06 18:12:06
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


import Subsystem_pkg::* ;

// -------------------------------------------------------------
// 
// Module: state_machine_FixPt
// Source Path: Simulink_SPGD_simulation_HDL_code_generator_v5_5/Subsystem/SPGD Subsystem/state_machine/state_machine_FixPt
// Hierarchy Level: 3
// Model version: 1.49
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module state_machine_FixPt
          (  input logic clk,
		     input logic [15:0] counter_in  /* ufix16_En12 */,
             input logic [2:0] cur_state  /* ufix16_En11 */,
             input logic [2:0] projected_state_in  /* ufix16_En11 */,
             input vector_of_unsigned_logic_16 wait_time_batch[0:7]  /* ufix16_En12 [8] */,
             input vector_of_unsigned_logic_16 hold_time_batch[0:7]  /* ufix16_En13 [8] */,
             output logic [15:0] counter_out  /* ufix16_En12 */,
             output logic DAC_enable_out,
             output logic J_plus_ADC_enable_out,
             output logic J_minus_ADC_enable_out,
             output logic plus_perturb_enable_out,
             output logic minus_perturb_enable_out,
             output logic SPGD_update_enable_out,
             output logic [2:0] next_state  /* ufix16_En11 */,
             output logic [2:0] projected_state  /* ufix16_En11 */,
             output logic [15:0] plus_minus_select  /* ufix16_En14 */);


  logic [15:0] counter_out_1;  /* ufix16_En12 */
  logic DAC_enable_out_1;
  logic J_plus_ADC_enable_out_1;
  logic J_minus_ADC_enable_out_1;
  logic plus_perturb_enable_out_1;
  logic minus_perturb_enable_out_1;
  logic SPGD_update_enable_out_1;
  logic [2:0] next_state_1;  /* ufix16_En11 */
  logic [2:0] projected_state_1;  /* ufix16_En11 */
  logic [15:0] plus_minus_select_1;  /* ufix16_En14 */
  logic [15:0] proceed_enable;  /* ufix16_En13 */
  logic [16:0] cast;  /* ufix17_En13 */
  logic [2:0] sub_cast;  /* int32 */
  logic [16:0] cast_0;  /* ufix17_En13 */
  logic [31:0] sub_cast_0;  /* int32 */
  logic [16:0] cast_1;  /* ufix17_En13 */
  logic [31:0] sub_cast_1;  /* int32 */
  logic [16:0] cast_2;  /* ufix17_En13 */
  logic counter_reset;

  always_ff @ (posedge clk) begin
      if (counter_reset == 1'b1) begin
          counter_out_1 <= 16'b0000000000000001;
      end
      else begin
          counter_out_1 <= counter_in + 16'b0000000000000001;
      end
      
  end
  
  always_comb begin
    if (counter_in < hold_time_batch[projected_state_in - 3'b1]) begin
      proceed_enable = 16'b0000000000000000;
      counter_reset = 1'b0;
    end
    else if ((counter_in >= hold_time_batch[projected_state_in - 3'b1]) && (counter_in < wait_time_batch[projected_state_in - 3'b1])) begin
      proceed_enable = 16'b0010000000000000;
      counter_reset = 1'b0;
    end
    else begin
      proceed_enable = 16'b0100000000000000;
      counter_reset = 1'b1;
    end
  end
    
    
    
    //State update
   always_ff @ (posedge clk) begin
    if (proceed_enable == 16'b0000000000000000) begin
      next_state_1 <= cur_state;
      projected_state_1 <= projected_state_in;
    end
    else if (proceed_enable == 16'b0010000000000000) begin
      next_state_1 <= 3'b000;
      projected_state_1 <= projected_state_in;
    end
    else begin
      //Idle
      if (projected_state_in == 3'b111) begin
        next_state_1 <= projected_state_in;
        projected_state_1 <= 3'b001;
      end
      else begin
        next_state_1 <= projected_state_in;
        projected_state_1 <= projected_state_in + 3'b001;
      end
    end
    //Send out enable signals based on state
  end

  
  always_ff @ (posedge clk) begin
      if (cur_state == 3'b001) begin
      DAC_enable_out_1 <= 1'b0;
      J_plus_ADC_enable_out_1 <= 1'b0;
      J_minus_ADC_enable_out_1 <= 1'b0;
      plus_perturb_enable_out_1 <= 1'b1;
      minus_perturb_enable_out_1 <= 1'b0;
      SPGD_update_enable_out_1 <= 1'b0;
      plus_minus_select_1 <= 16'b0100000000000000;
    end
    else if (cur_state == 3'b010) begin
      DAC_enable_out_1 <= 1'b1;
      J_plus_ADC_enable_out_1 <= 1'b0;
      J_minus_ADC_enable_out_1 <= 1'b0;
      plus_perturb_enable_out_1 <= 1'b0;
      minus_perturb_enable_out_1 <= 1'b0;
      SPGD_update_enable_out_1 <= 1'b0;
      plus_minus_select_1 <= plus_minus_select_1;
    end
    else if (cur_state == 3'b011) begin
      DAC_enable_out_1 <= 1'b0;
      J_plus_ADC_enable_out_1 <= 1'b1;
      J_minus_ADC_enable_out_1 <= 1'b0;
      plus_perturb_enable_out_1 <= 1'b0;
      minus_perturb_enable_out_1 <= 1'b0;
      SPGD_update_enable_out_1 <= 1'b0;
      plus_minus_select_1 <= plus_minus_select_1;
    end
    else if (cur_state == 3'b100) begin
      DAC_enable_out_1 <= 1'b0;
      J_plus_ADC_enable_out_1 <= 1'b0;
      J_minus_ADC_enable_out_1 <= 1'b0;
      plus_perturb_enable_out_1 <= 1'b0;
      minus_perturb_enable_out_1 <= 1'b1;
      SPGD_update_enable_out_1 <= 1'b0;
      plus_minus_select_1 <= 16'b0000000000000000;
    end
    else if (cur_state == 3'b101) begin
      DAC_enable_out_1 <= 1'b1;
      J_plus_ADC_enable_out_1 <= 1'b0;
      J_minus_ADC_enable_out_1 <= 1'b0;
      plus_perturb_enable_out_1 <= 1'b0;
      minus_perturb_enable_out_1 <= 1'b0;
      SPGD_update_enable_out_1 <= 1'b0;
      plus_minus_select_1 <= plus_minus_select_1;
    end
    else if (cur_state == 3'b110) begin
      DAC_enable_out_1 <= 1'b0;
      J_plus_ADC_enable_out_1 <= 1'b0;
      J_minus_ADC_enable_out_1 <= 1'b1;
      plus_perturb_enable_out_1 <= 1'b0;
      minus_perturb_enable_out_1 <= 1'b0;
      SPGD_update_enable_out_1 <= 1'b0;
      plus_minus_select_1 <= plus_minus_select_1;
    end
    else if (cur_state == 3'b111) begin
      DAC_enable_out_1 <= 1'b0;
      J_plus_ADC_enable_out_1 <= 1'b0;
      J_minus_ADC_enable_out_1 <= 1'b0;
      plus_perturb_enable_out_1 <= 1'b0;
      minus_perturb_enable_out_1 <= 1'b0;
      SPGD_update_enable_out_1 <= 1'b1;
      plus_minus_select_1 <= plus_minus_select_1;
    end
    else begin
      DAC_enable_out_1 <= 1'b0;
      J_plus_ADC_enable_out_1 <= 1'b0;
      J_minus_ADC_enable_out_1 <= 1'b0;
      plus_perturb_enable_out_1 <= 1'b0;
      minus_perturb_enable_out_1 <= 1'b0;
      SPGD_update_enable_out_1 <= 1'b0;
      plus_minus_select_1 <= plus_minus_select_1;
    end
  end


  assign counter_out = counter_out_1;

  assign DAC_enable_out = DAC_enable_out_1;

  assign J_plus_ADC_enable_out = J_plus_ADC_enable_out_1;

  assign J_minus_ADC_enable_out = J_minus_ADC_enable_out_1;

  assign plus_perturb_enable_out = plus_perturb_enable_out_1;

  assign minus_perturb_enable_out = minus_perturb_enable_out_1;

  assign SPGD_update_enable_out = SPGD_update_enable_out_1;

  assign next_state = next_state_1;

  assign projected_state = projected_state_1;

  assign plus_minus_select = plus_minus_select_1;

endmodule  // state_machine_FixPt
